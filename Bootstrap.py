#
# Bootstrapping New Data Sets
#


# Suppose we have a data sample generated by some unknown distribution
#
# Suppose we've made a statistic from the data
#
# How confident can we be about our statistic?
#
# If we had the option, we could get new samples, look at distribution of statistic over samples
#   but we often can't get new samples
#
# We can 'bootstrap' new data sets from old data sets by
#   choosing n data points 'with replacement' from our data
#       


from typing import TypeVar, Callable, List

X = TypeVar('X')        # generic type for 'data'
Stat = TypeVar('Stat')  # generic type for 'statistic'

# generates bootstrap sample
def bootstrap_sample(data: List[X]) -> List[X]:
    """randomly samles len(data) elements with replacement"""
    return np.array([random.choice(data) for _ in data])

# evaluates statistic on bootstrap samples
def bootstrap_statistic(data: List[X], 
                        stats_fn: Callable[[List[X]], Stat],
                        num_samples: int) -> np.ndarray:
    """evaluates stats_fn on num_samples bootstrap samples of data"""
    return np.array([stats_fn(bootstrap_sample(data)) for _ in range(num_samples)])


# example
import numpy as np

median = np.median

import random

# two samples from two different distributions
close_to_100 = np.array([99.5 + random.random() for _ in range(101)])
far_from_100 = np.array([99.5 + random.random()] +
               [random.random() for _ in range(50)] +
               [200 + random.random() for _ in range(50)])

# similar means
m1 = np.median(close_to_100)
m2 = np.median(far_from_100)
print(f"median(close_to_100): {m1}")
print(f"median(far_from_100): {m2}")
assert 99 < np.median(close_to_100) < 101
assert 99 < np.median(far_from_100) < 101
print('\n')

# bootstrap new samples to investigate
medians_close = bootstrap_statistic(close_to_100, np.mean, 100)
medians_far = bootstrap_statistic(far_from_100, np.mean, 100)

# low std, so confident in choice
print(f"mean(medians_close): {np.mean(medians_close)}")
print(f"std(medians_close): {np.std(medians_close)}")
print('\n')

# high std, so not confident in choice
print(f"mean(medians_far): {np.mean(medians_far)}")
print(f"std(medians_far): {np.std(medians_far)}")